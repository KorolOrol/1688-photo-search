import pandas as pd
import numpy as np
from sklearn.preprocessing import StandardScaler
from sklearn.ensemble import RandomForestRegressor
import tensorflow as tf
from prophet import Prophet
import json
from openai import OpenAI
from shap import Explainer

class SupplierRanker:
    def __init__(self):
        self.scaler = StandardScaler()
        self.rf_model = RandomForestRegressor()
        self.nn_model = self._build_nn_model()
        self.required_features = [
            'years_active',
            'return_rate', 
            'order_count',
            'customer_count',
            'composite_rating'
        ]


    def _build_nn_model(self):
        '''построение нейронной сети.'''

        return tf.keras.Sequential([
            tf.keras.layers.Dense(64, activation='relu', input_shape=(5,)),
            tf.keras.layers.Dropout(0.2),
            tf.keras.layers.Dense(1)
        ])

    def preprocess_data(self, json_data):
        '''преобразование json в pandas DataFrame.'''

        df = pd.json_normalize(json_data, sep='_')

        # Проверка обязательных полей
        required_columns = ['business_type', 'years_active', 'rating_service',
                        'rating_product', 'return_rate', 'order_count']
    
        if not set(required_columns).issubset(df.columns):
            missing = set(required_columns) - set(df.columns)
            raise ValueError(f'Отсутствуют обязательные поля: {missing}')
        
        df['business_type'] = df['business_type'].map({'manufacturer': 1, 'reseller': 0})
        
        df['composite_rating'] = df[['rating_service', 'rating_logistics',
                                    'rating_product']].mean(axis=1)
        
        numerical_features = ['years_active', 'return_rate', 'order_count', 
                             'customer_count', 'composite_rating']
        df[numerical_features] = self.scaler.fit_transform(df[numerical_features])
        
        return df

    def forecast_orders(self, order_history):
        '''Предсказание количества заказов на следующий месяц по истории заказов.'''

        # Конвертируем сырые данные в DataFrame для Prophet
        df = pd.DataFrame({
        'ds': pd.date_range(end=pd.Timestamp.today(), 
                           periods=len(order_history)),  # Генерируем даты
        'y': order_history  # Предполагаем, что order_history - список чисел
    })
        
        # Объявляем модель Prophet
        model = Prophet()
        model.fit(df)
        
        # Предсказание
        future = model.make_future_dataframe(periods=30)
        forecast = model.predict(future)
        return forecast['yhat'].iloc[-1]  # Берем последний прогнозируемый день

    def train_ranking_model(self, X, y):
        '''Тренировка модели ранжирования.'''

        # Проверка наличия всех фичей
        if not set(self.required_features).issubset(X.columns):
            missing = set(self.required_features) - set(X.columns)
            raise ValueError(f'Отсутствуют фичи: {missing}')

        # Обучение RandomForest
        self.rf_model.fit(X[self.required_features], y)

        # Обучение нейросети
        X_scaled = self.scaler.fit_transform(X[self.required_features])
        self.nn_model.compile(optimizer='adam', loss='mse')
        self.nn_model.fit(X_scaled, y, epochs=50, batch_size=32, verbose=0)
    
    def calculate_supplier_score(self, df):
        '''Предсказывание рейтинга поставщика.'''
        # Достаём требуемые фичи
        features = df[self.required_features]

        #предсказание RandomForest
        rf_score = self.rf_model.predict(features)
        #предсказание NeuralNetwork
        nn_score = self.nn_model.predict(
            self.scaler.transform(features),
            verbose=0
        ).flatten()

        return 0.7*rf_score + 0.3*nn_score

    def generate_explanation(self, supplier_data):
        '''Генерация объяснения для продавца.'''
        #TODO сделать нормальный промпт
        client = OpenAI(base_url ='http://127.0.0.1:1234/v1', api_key='lm-studio')
        explanation_prompt = f'''there are suppliers of goods with the following characteristics: {supplier_data}.
        generated_rating this field is generated by the algorithm and displays the overall rating of the supplier.
        you need to briefly and clearly explain to the buyer why the seller received such a rating and tell about the pros and cons of this supplier.
        '''

        response = client.chat.completions.create(
        model='deepseek-r1-distill-qwen-7b', #модель выбиралась наугад. так что лучше найти что-то адекватное
        messages=[{'role': 'user', 'content': explanation_prompt}],
        temperature=0.7,
        max_tokens=-1)

        return response.choices[0].message.content


'''Далее идёт пример использования и обучения, когда будет готова выборка это стоит перенести в отдельные файлы'''
#TODO:сделать нормальную выборку
with open('project\\backend\\testdata.json', 'r') as f:
    loaded_data = json.load(f)

#создаём экземпляр
ranker = SupplierRanker()

#готвим данные
df = ranker.preprocess_data(loaded_data)

#датафрейм для промпта ИИшке
supplier_data = pd.DataFrame(loaded_data)

# Прогнозирование заказов (демонстрация для одного поставщика)(сомнительная функциональность)
sample_supplier = df.iloc[0]
forecast = ranker.forecast_orders(sample_supplier['order_history'])
print(f'Прогноз заказов на следующий месяц: {forecast:.1f}')

# После препроцессинга данных
X_demo = df[[
    'years_active',
    'return_rate',
    'order_count',
    'customer_count', 
    'composite_rating'
]]

y_demo = np.array([0.5, 0.5, 0.8])  # Пример целевых значений

ranker.train_ranking_model(X_demo, y_demo)

# Обучение модели
#TODO:в продакшн нужно разделение на train/test
ranker.train_ranking_model(X_demo, y_demo)

# Получение итоговых оценок
supplier_scores = ranker.calculate_supplier_score(X_demo)
print('\nРейтинги поставщиков:')
for idx, score in enumerate(supplier_scores):
    print(f'Поставщик #{idx+1}: {score:.2f}')

#для промпта добавляем вычисленные оценки продавца
supplier_data['generated_rating'] = supplier_scores

print(ranker.generate_explanation(supplier_data))